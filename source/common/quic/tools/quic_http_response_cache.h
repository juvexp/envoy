// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef GFE_QUIC_TOOLS_QUIC_HTTP_RESPONSE_CACHE_H_
#define GFE_QUIC_TOOLS_QUIC_HTTP_RESPONSE_CACHE_H_

#include <list>
#include <map>
#include <memory>
#include <string>
#include <vector>

#include "base/macros.h"
#include "common/quic/core/spdy_utils.h"
#include "common/quic/platform/api/quic_containers.h"
#include "common/quic/platform/api/quic_mutex.h"
#include "common/quic/platform/api/quic_string_piece.h"
#include "common/quic/platform/api/quic_url.h"
#include "common/quic/spdy_utils/core/spdy_framer.h"

namespace gfe_quic {

// In-memory cache for HTTP responses.
// Reads from disk cache generated by:
// `wget -p --save_headers <url>`
class QuicHttpResponseCache {
 public:
  // A ServerPushInfo contains path of the push request and everything needed in
  // comprising a response for the push request.
  struct ServerPushInfo {
    ServerPushInfo(QuicUrl request_url,
                   gfe_spdy::SpdyHeaderBlock headers,
                   gfe_spdy::SpdyPriority priority,
                   string body);
    ServerPushInfo(const ServerPushInfo& other);
    QuicUrl request_url;
    gfe_spdy::SpdyHeaderBlock headers;
    gfe_spdy::SpdyPriority priority;
    string body;
  };

  enum SpecialResponseType {
    REGULAR_RESPONSE,  // Send the headers and body like a server should.
    CLOSE_CONNECTION,  // Close the connection (sending the close packet).
    IGNORE_REQUEST,    // Do nothing, expect the client to time out.
  };

  // Container for response header/body pairs.
  class Response {
   public:
    Response();
    ~Response();

    SpecialResponseType response_type() const { return response_type_; }
    const gfe_spdy::SpdyHeaderBlock& headers() const { return headers_; }
    const gfe_spdy::SpdyHeaderBlock& trailers() const { return trailers_; }
    const QuicStringPiece body() const { return QuicStringPiece(body_); }

    void set_response_type(SpecialResponseType response_type) {
      response_type_ = response_type;
    }
    void set_headers(gfe_spdy::SpdyHeaderBlock headers) {
      headers_ = std::move(headers);
    }
    void set_trailers(gfe_spdy::SpdyHeaderBlock trailers) {
      trailers_ = std::move(trailers);
    }
    void set_body(QuicStringPiece body) {
      body_.assign(body.data(), body.size());
    }

   private:
    SpecialResponseType response_type_;
    gfe_spdy::SpdyHeaderBlock headers_;
    gfe_spdy::SpdyHeaderBlock trailers_;
    string body_;

    DISALLOW_COPY_AND_ASSIGN(Response);
  };

  // Class to manage loading a resource file into memory.  There are
  // two uses: called by InitializeFromDirectory to load resources
  // from files, and recursively called when said resources specify
  // server push associations.
  class ResourceFile {
   public:
    explicit ResourceFile(const string& file_name);
    virtual ~ResourceFile();

    void Read();

    // |base| is |file_name_| with |cache_directory| prefix stripped.
    void SetHostPathFromBase(QuicStringPiece base);

    const string& file_name() { return file_name_; }

    QuicStringPiece host() { return host_; }

    QuicStringPiece path() { return path_; }

    const gfe_spdy::SpdyHeaderBlock& spdy_headers() { return spdy_headers_; }

    QuicStringPiece body() { return body_; }

    const std::vector<QuicStringPiece>& push_urls() { return push_urls_; }

   protected:
    void HandleXOriginalUrl();
    QuicStringPiece RemoveScheme(QuicStringPiece url);

    string file_name_;
    string file_contents_;
    QuicStringPiece body_;
    gfe_spdy::SpdyHeaderBlock spdy_headers_;
    QuicStringPiece x_original_url_;
    std::vector<QuicStringPiece> push_urls_;

   private:
    QuicStringPiece host_;
    QuicStringPiece path_;

    DISALLOW_COPY_AND_ASSIGN(ResourceFile);
  };

  QuicHttpResponseCache();
  ~QuicHttpResponseCache();

  // Retrieve a response from this cache for a given host and path..
  // If no appropriate response exists, nullptr is returned.
  const Response* GetResponse(QuicStringPiece host, QuicStringPiece path) const;

  // Adds a simple response to the cache.  The response headers will
  // only contain the "content-length" header with the length of |body|.
  void AddSimpleResponse(QuicStringPiece host,
                         QuicStringPiece path,
                         int response_code,
                         QuicStringPiece body);

  // Add a simple response to the cache as AddSimpleResponse() does, and add
  // some server push resources(resource path, corresponding response status and
  // path) associated with it.
  // Push resource implicitly come from the same host.
  void AddSimpleResponseWithServerPushResources(
      QuicStringPiece host,
      QuicStringPiece path,
      int response_code,
      QuicStringPiece body,
      std::list<ServerPushInfo> push_resources);

  // Add a response to the cache.
  void AddResponse(QuicStringPiece host,
                   QuicStringPiece path,
                   gfe_spdy::SpdyHeaderBlock response_headers,
                   QuicStringPiece response_body);

  // Add a response, with trailers, to the cache.
  void AddResponse(QuicStringPiece host,
                   QuicStringPiece path,
                   gfe_spdy::SpdyHeaderBlock response_headers,
                   QuicStringPiece response_body,
                   gfe_spdy::SpdyHeaderBlock response_trailers);

  // Simulate a special behavior at a particular path.
  void AddSpecialResponse(QuicStringPiece host,
                          QuicStringPiece path,
                          SpecialResponseType response_type);

  // Sets a default response in case of cache misses.  Takes ownership of
  // 'response'.
  void AddDefaultResponse(Response* response);

  // |cache_cirectory| can be generated using `wget -p --save-headers <url>`.
  void InitializeFromDirectory(const string& cache_directory);

  // Find all the server push resources associated with |request_url|.
  std::list<ServerPushInfo> GetServerPushResources(string request_url);

 private:
  void AddResponseImpl(QuicStringPiece host,
                       QuicStringPiece path,
                       SpecialResponseType response_type,
                       gfe_spdy::SpdyHeaderBlock response_headers,
                       QuicStringPiece response_body,
                       gfe_spdy::SpdyHeaderBlock response_trailers);

  string GetKey(QuicStringPiece host, QuicStringPiece path) const;

  // Add some server push urls with given responses for specified
  // request if these push resources are not associated with this request yet.
  void MaybeAddServerPushResources(QuicStringPiece request_host,
                                   QuicStringPiece request_path,
                                   std::list<ServerPushInfo> push_resources);

  // Check if push resource(push_host/push_path) associated with given request
  // url already exists in server push map.
  bool PushResourceExistsInCache(string original_request_url,
                                 ServerPushInfo resource);

  // Cached responses.
  QuicUnorderedMap<string, std::unique_ptr<Response>> responses_
      GUARDED_BY(response_mutex_);

  // The default response for cache misses, if set.
  std::unique_ptr<Response> default_response_ GUARDED_BY(response_mutex_);

  // A map from request URL to associated server push responses (if any).
  std::multimap<string, ServerPushInfo> server_push_resources_
      GUARDED_BY(response_mutex_);

  // Protects against concurrent access from test threads setting responses, and
  // server threads accessing those responses.
  mutable QuicMutex response_mutex_;

  DISALLOW_COPY_AND_ASSIGN(QuicHttpResponseCache);
};

}  // namespace gfe_quic

#endif  // GFE_QUIC_TOOLS_QUIC_HTTP_RESPONSE_CACHE_H_
